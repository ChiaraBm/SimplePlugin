using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SimplePlugin.Generator;

[Generator]
public class PluginDiscoveryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(context.CompilationProvider, (productionContext, compilation) =>
        {
            var pluginInterface = compilation.GetTypeByMetadataName("SimplePlugin.IPluginModule");
            var pluginAttribute = compilation.GetTypeByMetadataName("SimplePlugin.PluginModuleAttribute");

            if (pluginInterface is null || pluginAttribute is null)
                return;

            var allTypes = AnalyzeHelper.GetAllTypes(compilation.SourceModule);

            var modules = new List<string>();

            foreach (var type in allTypes)
            {
                var hasAttr = HasAttribute(type, pluginAttribute);
                var implementsInterface = ImplementsInterface(type, pluginInterface);
                var hasParamlessCtor = HasParameterlessConstructor(type);
                var isPublic = type.DeclaredAccessibility == Accessibility.Public;
                var isClass = type.TypeKind == TypeKind.Class;
                var isAbstract = type.IsAbstract;

                // Log candidates (types that have either the attribute or implement the interface)
                if (!hasAttr && !implementsInterface)
                    continue;

                if (!isClass || isAbstract || !isPublic || !hasAttr || !implementsInterface || !hasParamlessCtor)
                    continue;

                var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                modules.Add(fullName);
            }

            var source = GenerateRegistration(modules);
            productionContext.AddSource("PluginRegistry.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool HasParameterlessConstructor(INamedTypeSymbol type)
    {
        var constructors = type.Constructors.Where(c => !c.IsStatic).ToList();

        if (constructors.Count == 0)
            return true;

        return constructors.Any(c =>
            c.Parameters.Length == 0 &&
            c.DeclaredAccessibility == Accessibility.Public
        );
    }

    private static bool HasAttribute(INamedTypeSymbol type, INamedTypeSymbol attribute)
    {
        return type.GetAttributes().Any(attr =>
            SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attribute));
    }

    private static bool ImplementsInterface(INamedTypeSymbol type, INamedTypeSymbol iface)
    {
        return type.AllInterfaces.Contains(iface, SymbolEqualityComparer.Default);
    }

    private static string GenerateRegistration(List<string> modules)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using SimplePlugin;");
        sb.AppendLine();
        sb.AppendLine("namespace SimplePlugin.Generated;");
        sb.AppendLine();
        sb.AppendLine("public static class PluginRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    public static IPluginModule[] GetAllModules()");
        sb.AppendLine("    {");

        if (modules.Count == 0)
        {
            sb.AppendLine("        return System.Array.Empty<IPluginModule>();");
        }
        else
        {
            sb.AppendLine("        return new IPluginModule[]");
            sb.AppendLine("        {");

            foreach (var module in modules.Distinct())
            {
                sb.AppendLine($"            new {module}(),");
            }

            sb.AppendLine("        };");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}